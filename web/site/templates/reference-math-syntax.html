{% extends "reference.html" %}

{% block reference %}

<h2>Game Math: Syntax</h2>

<div id="page-menu">
  <h3>Topics</h3>
  <ul>
    <li><a href="#types-packages">Types and Packages</a></li>
    <li><a href="#operations">Operations</a></li>
  </ul>
</div>

<div id="types-packages" class="ref-topic">
  <h3>Types and Packages</h3>
  <p>
    Each of the math types that Origin supports and their associated operations
    are located in a distinct package. As such, each constructor or operator
    requires a package name, followed by a colon, followed by the function name.
    Additionally, Pyx offers a convenience using "package-local nicknames" which
    allows these packages to be abbreviated only in the context of a Pyx game
    project.
  </p>
  <p>
    The following table lists all math types and their containing package for
    both Origin proper and within the context of a Pyx game project:
  </p>
  <table>
    <tr>
      <th>Type</th>
      <th>Origin</th>
      <th>Pyx</th>
    </tr>
    <tr>
      <td>2D Vector</td>
      <td>ORIGIN.VEC2</td>
      <td>V2</td>
    </tr>
    <tr>
      <td>3D Vector</td>
      <td>ORIGIN.VEC3</td>
      <td>V3</td>
    </tr>
    <tr>
      <td>4D Vector</td>
      <td>ORIGIN.VEC4</td>
      <td>V4</td>
    </tr>
    <tr>
      <td>2x2 Matrix</td>
      <td>ORIGIN.MAT2</td>
      <td>M2</td>
    </tr>
    <tr>
      <td>3x3 Matrix</td>
      <td>ORIGIN.MAT3</td>
      <td>M3</td>
    </tr>
    <tr>
      <td>4x4 Matrix</td>
      <td>ORIGIN.MAT4</td>
      <td>M4</td>
    </tr>
    <tr>
      <td>Quaternion</td>
      <td>ORIGIN.QUAT</td>
      <td>Q</td>
    </tr>
  </table>
  <p>
    Thus, to create a 3D vector within the context of a Pyx game project, you
    would prefix <code>V3:</code> followed by the constructor function
    <code>VEC</code>, and the three arguments for the components as such:
  </p>
  <div class="code-block">
    <pre><code class="lisp">(v3:vec 1 2 3)</code></pre>
  </div>
</div>

<div id="operations" class="ref-topic">
  <h3>Operations</h3>
  <p>
    Nearly all mathmematical operations in Origin have two forms: an in-place
    operation, and an allocating operation. The in-place operations writes the
    result to an existing math type that has been previously allocated, which is
    very useful for performance reasons.
  </p>
  <p>
    The syntax for an in-place operation is just like the allocating version,
    except with an exclamation point (<code>!</code>) appended to the operator
    name, and it has 1 extra parameter which appears first.
  </p>
  <p>
    The <code>!</code> suffix notation is borrowed from the conventions of the
    Scheme language and was chosen over the more conventional <code>N</code> prefix
    notation of Common Lisp in order to be a bit more readable and resolve some
    conflicts. For example, there is such as thing as a normalized quaternion
    interpolation (<code>NLERP</code>), which would become ambiguous with the
    in-place variant of a standard <code>LERP</code> operation.
  </p>
  <p>
    The following table lists an example of both allocating and in-place
    operations for vector addition:
  </p>
  <table>
    <tr>
      <th>Variant</th>
      <th>Example Usage</th>
      <th>Result</th>
    </tr>
    <tr>
      <td>Allocating</td>
      <td><code>(v3:+ vec-a vec-b)</code></td>
      <td>A freshly-allocated 3D vector object</td>
    </tr>
    <tr>
      <td>In-place</td>
      <td><code>(v3:+! vec-b vec-a vec-b)</code></td>
      <td>Adds <code>VEC-A</code> and <code>VEC-B</code>, storing the result
        into <code>VEC-B</code>
      </td>
    </tr>
  </table>
</div>

{% endblock reference %}
