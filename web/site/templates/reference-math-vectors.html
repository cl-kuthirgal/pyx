{% extends "reference.html" %}

{% block reference %}

<h2>Game Math: Vectors</h2>
<p>
  A vector is a set of components typically used to describe a point in space or
  a direction. For more information about vectors, see
  <a href="https://en.wikipedia.org/wiki/Euclidean_vector" target="_blank">
    this Wikipedia entry</a>. Origin supports 2, 3, and 4-dimensional vectors.
</p>

<div id="page-menu">
  <h3>Topics</h3>
  <ul>
    <li><a href="#initialization">Initialization</a></li>
    <li><a href="#accessors">Accessors</a></li>
    <li><a href="#assignment">Assignment</a></li>
    <li><a href="#constants">Constants</a></li>
    <li><a href="#arithmetic">Arithmetic</a></li>
    <li><a href="#boolean-operations">Boolean Operations</a></li>
    <li><a href="#geometric-operations">Geometric Operations</a></li>
    <li><a href="#other-operations">Other Operations</a></li>
  </ul>
</div>

<div id="initialization" class="ref-topic">
  <h3>Initialization</h3>
  <p>
    A new vector can be initialized using the <code>VEC</code> function with a
    package qualifier prefixed corresponding to the desired dimension:
    <div class="code-block">
      <pre><code class="lisp">(v2:vec 1 2)
(v3:vec 1 2 3)
(v4:vec 1 2 3 4)</code></pre>
    </div>
  </p>
  <p>
    The above code listing is an example of how to initialize a 2D, 3D, and 4D
    vector, respectively. The resulting vectors will have each component
    automatically coerced to a single-precision 32-bit floating point number.
    All arguments are required for each dimension. That is, to create a 4D
    vector, all 4 arguments for the X, Y, Z, and W components must be supplied
    to <code>VEC</code>.
  </p>
  <p>
    Additionally, 2 convenient vector construction functions are also provided,
    in the case you want to initialize all components to 0, or all components to
    1:
    <div class="code-block">
      <pre><code class="lisp">(v3:zero)
(v3:one)</code></pre>
    </div>
  </p>
  <p>
    The above code listing will construct a 3D vector with all components
    initialized to 0, and all components initialized to 1, respectively.
  </p>
</div>

<div id="accessors" class="ref-topic">
  <h3>Accessors</h3>
  <p>
    Origin provides three ways to access the components of a vector: a
    functional, array, and macro style. Each of these styles allows both getting
    and setting (via <code>SETF</code>) a component.
    <ul>
      <li>Functional style</li>
      <p>
        The functional style allows you to access a component of a vector by
        calling a function denoting the component position into the vector. For
        example, to access the component in the Z position of a 4D vector, you
        would use the <code>V4:Z</code> function, such as <code>(v4:z (v4:vec 1
        2 3 4))</code>, which would return <code>3.0</code>.
      </p>
      <p>
        Functional accessors exist for all other components of the particular
        vector type being operated on. Note: it is illegal to use a function
        from one vector type's package on an incompatible vector type. For
        example, the above would not work if you used <code>V3:Z</code> instead
        of <code>V4:Z</code>, since the vector being operated on is a 4D vector,
        not a 3D vector.
      </p>
      <li>Array style</li>
      <p>
        Vectors are represented in memory as arrays, so you can access their
        components just as you would with any other array. For example, to
        access the Z component of a 4D vector, you could issue <code>(aref
        (v4:vec 1 2 3 4) 2)</code>, which would return <code>3.0</code>, since
        the Z component is the third component of the array (0-indexed).
      </p>
      <li>Macro style</li>
      <p>
        The macro style is the most flexible, and most concise when more complex
        operations need to be performed. It is recommended especially when
        dealing with multiple vectors at the same time.
      </p>
      <div class="code-block">
        <pre><code class="lisp">(v4:with-components ((a (v4:make 1 2 3 4)))
  az)</code></pre>
      </div>
      <p>
        The above will access the Z component of the 4D vector, and returns
        <code>3.0</code>. It works by concatenating the name you give it (here
        <code>A</code>) and the component name (here <code>Z</code>). You can
        also work with multiple 4D vectors at the same time, such as:
      </p>
      <div class="code-block">
        <pre><code class="lisp">(v4:with-components ((a (v4:vec 1 2 3 4))
                     (b (v4:vec 5 6 7 8)))
  (values az bw))</code></pre>
      </div>
      <p>
        Additionally, it can be quite handy to nest <code>WITH-COMPONENTS</code>
        of varying vector dimensions, in order to have a body that can concisely
        access the components of many different vectors of varying types. For
        example:
      </p>
      <div class="code-block">
        <pre><code class="lisp">(v4:with-components ((a (v4:vec 1 2 3 4))
                     (b (v4:vec 5 6 7 8)))
  (v3:with-components ((c (v3:vec 9 10 11))
                       (d (v3:vec 12 13 14)))
    (values az bw cy dx)))</code></pre>
      </div>
    </ul>
  </p>
</div>

<div id="assignment" class="ref-topic">
  <h3>Assignment</h3>
  <p>
    Each of the above vector accessor styles also supports assignment with
    <code>SETF</code>, and works exactly as you would expect.
  </p>
</div>

<div id="constants" class="ref-topic">
  <h3>Constants</h3>
  <p>
    A constant named <code>+ZERO+</code> for a pre-allocated zero vector exists
    for each of the three vector types. This is useful for when you need a
    read-only vector with a zero value for each component.
  </p>
  <div class="message">
    <p>
      <i class="fa fa-exclamation"></i>
      Important
    </p>
    You should not attempt to modify this constant, as no checks are performed
    to prevent this from happening. This should <i>never</i> be passed as the
    first argument to an in-place operator (denoted by the <code>!</code>
    suffix).
  </div>
</div>

<div id="arithmetic" class="ref-topic">
  <h3>Arithmetic</h3>
  <p>
    Component-wise arithmetic for addition, subtraction, multiplication, and
    division is supported for both allocating and in-place operations. The
    following code provides examples of each for 3D vectors:
    <div class="code-block">
      <pre><code class="lisp">;; Addition (allocating)
(v3:+ vec-a vec-b)

;; Addition (in-place)
(v3:+! vec-c vec-a vec-b)

;; Subtraction (allocating)
(v3:- vec-a vec-b)

;; Subtraction (in-place)
(v3:-! vec-c vec-a vec-b)

;; Multiplication (allocating)
(v3:* vec-a vec-b)

;; Multiplication (in-place)
(v3:*! vec-c vec-a vec-b)

;; Division (allocating)
(v3:/ vec-a vec-b)

;; Division (in-place)
(v3:/! vec-c vec-a vec-b)</code></pre>
    </div>
  </p>
</div>

<div id="boolean-operations" class="ref-topic">
  <h3>Boolean Operations</h3>
  <p>
    There exists a variety of boolean operations for vectors. These differ from
    most other vector operations in that they return a boolean true or false
    value, rather than a vector object. The following table outlines the
    available boolean operations, using 3D vectors for the examples:
  </p>
  <table>
    <tr>
      <th>Operator</th>
      <th>Example</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>ZERO-P</code></td>
      <td><code>(v3:zero-p vec)</code></td>
      <td>Checks whether <code>VEC</code> has each component set to 0.</td>
    </tr>
    <tr>
      <td><code>=</code></td>
      <td><code>(v3:= vec-a vec-b)</code></td>
      <td>Checks whether <code>VEC-A</code> and <code>VEC-B</code> have the same
        component values.
      </td>
    </tr>
    <tr>
      <td><code>~</code></td>
      <td><code>(v3:~ vec-a vec-b)</code></td>
      <td>
        Checks whether <code>VEC-A</code> and <code>VEC-B</code> have
        component values that are nearly the same (within a tolerance of 10⁻⁷).
      </td>
    </tr>
    <tr>
      <td><code>DIRECTION=</code></td>
      <td><code>(v3:direction= vec-a vec-b)</code></td>
      <td>
        Checks whether <code>VEC-A</code> and <code>VEC-B</code> have the same
        direction.
      </td>
    </tr>
    <tr>
      <td><code>PARALLEL-P</code></td>
      <td><code>(v3:parallel-p vec-a vec-b)</code></td>
      <td>
        Checks whether <code>VEC-A</code> and <code>VEC-B</code> are parallel
        to each other.
      </td>
    </tr>
    <tr>
      <td><code>&lt;</code></td>
      <td><code>(v3:< vec-a vec-b)</code></td>
      <td>
        Checks whether each component of <code>VEC-A</code> is less than the
        corresponding components of <code>VEC-B</code>.
      </td>
    </tr>
    <tr>
      <td><code>&lt;=</code></td>
      <td><code>(v3:<= vec-a vec-b)</code></td>
      <td>
        Checks whether each component of <code>VEC-A</code> is less than or
        equal to the corresponding components of <code>VEC-B</code>.
      </td>
    </tr>
    <tr>
      <td><code>&gt;</code></td>
      <td><code>(v3:> vec-a vec-b)</code></td>
      <td>
        Checks whether each component of <code>VEC-A</code> is greater than the
        corresponding components of <code>VEC-B</code>.
      </td>
    </tr>
    <tr>
      <td><code>&gt;=</code></td>
      <td><code>(v3:>= vec-a vec-b)</code></td>
      <td>
        Checks whether each component of <code>VEC-A</code> is greater than or
        equal to the corresponding components of <code>VEC-B</code>.
      </td>
    </tr>
  </table>
</div>

<div id="geometric-operations" class="ref-topic">
  <h3>Geometric Operations</h3>
  <p>
    There are several functions for common geometric operations useful for
    graphics programming.
  </p>
  <p>
    To calculate the length (magnitude) of a vector, there is the
    <code>LENGTH</code> operator. There is also a less expensive
    <code>LENGTH-SQUARED</code> for when the square root is not needed.
  </p>
  <p>
  </p>
  <p>
    <code>SCALE</code> can be used to alter a vector's magnitude.
  </p>
  <p>
    Vector scalar multiplication (dot product) can be computed with the
    <code>DOT</code> operator.
  </p>
  <p>
    The cross product of two 3D vectors can be computed with <code>CROSS</code>.
  </p>
</div>

<div id="other-operations" class="ref-topic">
  <h3>Other Operations</h3>
  <p>
    Origin supports many other operations that can be performed with vectors.
    Please refer to the non-exhaustive
    <a href="/reference/math/api">API Reference</a> for more information.
  </p>
</div>

{% endblock reference %}
